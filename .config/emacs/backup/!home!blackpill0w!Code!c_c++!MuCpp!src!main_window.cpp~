#include "./main_window.hpp"

#include <filesystem>

#include <QUiLoader>
#include <QFile>
#include <QStandardPaths>
#include <QDir>
#include <QtWidgets/QFileDialog>
#include <QtWidgets/QFrame>

#include "./album_widget.hpp"
#include "./flow_layout.hpp"

namespace fs = std::filesystem;

namespace mucpp {
MainWindow::MainWindow() {
  QString config_dir{QStandardPaths::writableLocation(QStandardPaths::AppConfigLocation)};
  std::string db_file{config_dir.toStdString() + fs::path::preferred_separator +
                      "music_library.sqlite"};

  fs::create_directory(config_dir.toStdString());

  m_db = std::make_unique<SQLite::Database>(db_file, SQLite::OPEN_CREATE | SQLite::OPEN_READWRITE);
  MusicIndexer::init_database(*m_db);

  QFile f{"../ui/main_win.ui"};
  f.open(QIODevice::ReadOnly);

  QUiLoader loader;

  m_main_win = static_cast<QMainWindow *>(loader.load(&f));
  assert((m_main_win != nullptr) && "1");

  m_content_sa = m_main_win->findChild<QScrollArea *>("contentSA");
  assert((m_content_sa != nullptr) && "2");
  m_content_sa->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOn);
  m_content_sa->setWidgetResizable(true);

  m_albums_frame = new QFrame(m_main_win);
  new FlowLayout(m_albums_frame);

  m_content_sa->setWidget(m_albums_frame);
  update_albums();

  QFile f2{"../ui/settings_frame.ui"};
  f2.open(QIODevice::ReadOnly);
  f.reset();

  m_settings_button = m_main_win->findChild<QPushButton *>("settingsPB");
  m_settings_frame  = loader.load(&f2)->findChild<QFrame *>("settingsF");
  QWidget::connect(m_settings_button, &QPushButton::pressed,
                   [&]() { this->show_settings_frame(); });

  auto *add_mdir_pb = m_settings_frame->findChild<QPushButton *>("addMDirPB");
  QWidget::connect(add_mdir_pb, &QPushButton::pressed, [&]() {
    QString dir = QFileDialog::getExistingDirectory(m_settings_frame, "Add a directory",
                                                    "", QFileDialog::ShowDirsOnly);
    MusicIndexer::insert<MusicIndexer::MusicDir>(*m_db, dir.toStdString());
    MusicIndexer::build_music_library(*m_db);
    update_albums();
    show_albums_frame();
  });
}

void MainWindow::run() {
  if (m_main_win != nullptr)
    m_main_win->show();
  else
    exit(1);
}

void MainWindow::show_settings_frame() { m_content_sa->setWidget(m_settings_frame); }
void MainWindow::show_albums_frame() { m_content_sa->setWidget(m_albums_frame); }

void MainWindow::update_albums() {
  while (!m_albums_frame->layout()->isEmpty()) {
    m_albums_frame->layout()->takeAt(0)->widget()->deleteLater();
  }
  const auto albums{MusicIndexer::get_all<MusicIndexer::Album>(*m_db)};

  for (auto &a : albums) {
    std::string album_art {
      MusicIndexer::data_dir + fs::path::preferred_separator + std::to_string(a.id)
    };
    if (!fs::exists(album_art)) {
      album_art.clear();
    }
    auto *w = new AlbumWidget(album_art.c_str(), m_albums_frame);
    m_albums_frame->layout()->addWidget(w);
  }
}
}  // namespace mucpp